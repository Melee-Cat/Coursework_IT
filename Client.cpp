#include <iostream>
#include <fstream>
#include <windows.h>
#include <string>
#include <map>
#define _WINSOCK_DEPRECATED_NO_WARNINGS
#define IP_ADDR "127.0.0.1"
#define PORT 7777
#pragma comment(lib, "ws2_32.lib")
#pragma warning(disable: 4996)
using namespace std;
SOCKET Connection;
string answer;
string username, password;
//ОПИСАНИЕ ФУНКЦИИ void SendMsg(string msg)
/*
Эта функция отправляет строковое сообщение msg по сети через сокет Connection.
Сначала функция определяет размер сообщения msg с помощью метода size() класса std::string и сохраняет его в переменную msg_size.
Затем она отправляет размер сообщения в виде массива из sizeof(int) байтов через функцию send(), преобразовав указатель на переменную msg_size к типу char* с помощью оператора& .
После этого она отправляет само сообщение msg в виде массива символов(строки C - style) через функцию send(), используя метод c_str() класса std::string для получения указателя на начало строки и размер сообщения msg_size.
Функция использует переданный ей сокет Connection, чтобы отправить сообщение.Обратите внимание, что функция не проверяет успешность отправки сообщения или возникновение ошибок, связанных с сокетом.
*/
void SendMsg(string msg) //Функция отправки сообщений
{
	int msg_size = msg.size();
	send(Connection, (char*)&msg_size, sizeof(int), NULL);
	send(Connection, msg.c_str(), msg_size, NULL);
}
//ОПИСАНИЕ ФУНКЦИИ void SendInt(int value)
/*
Эта функция отправляет целочисленное значение value через сокет Connection.
Функция использует функцию send() для отправки значения через сокет. 
Первый параметр send() - это сокет, который используется для отправки данных. В данном случае, это сокет Connection.
Второй параметр - это указатель на значение, которое нужно отправить. Так как send() ожидает указатель на массив байтов, мы используем оператор & для получения адреса value в памяти и приводим этот адрес к типу char*, чтобы отправить его через сокет.
Третий параметр - это размер данных, которые нужно отправить, в байтах. В данном случае, мы используем sizeof(int), чтобы отправить 4 байта (32 бита), которые занимает тип int.
Четвертый параметр - это дополнительные флаги, которые управляют поведением функции send(). В данном случае, мы передаем значение NULL, что означает отсутствие дополнительных флагов.
Функция использует переданный ей сокет Connection, чтобы отправить значение. Обратите внимание, что функция не проверяет успешность отправки сообщения или возникновение ошибок, связанных с сокетом.
*/
void SendInt(int value) //Функция отправки целочисленных сообщени
{
	send(Connection, (char*)&value, sizeof(int), NULL);
}
//ОПИСАНИЕ ФУНКЦИИ string RecvMsg()
/*
Эта функция принимает строковое сообщение через сокет Connection.
Функция использует функцию recv() для получения сообщения через сокет. 
Первый параметр recv() - это сокет, который используется для получения данных. В данном случае, это сокет Connection.
Второй параметр - это указатель на буфер, в который будут записаны полученные данные. В данном случае, мы используем оператор & для получения адреса переменной msg_size в памяти и приводим этот адрес к типу char*, чтобы получить данные через сокет.
Третий параметр - это размер данных, которые нужно принять, в байтах. В данном случае, мы ожидаем получить 4 байта (32 бита), которые занимает тип int.
Четвертый параметр - это дополнительные флаги, которые управляют поведением функции recv(). В данном случае, мы передаем значение NULL, что означает отсутствие дополнительных флагов.
Далее функция выделяет память для буфера msg, в котором будут храниться полученные данные. Размер этого буфера вычисляется как msg_size + 1, чтобы вместить полученные данные и завершающий символ строки \0.
Затем функция вызывает recv() с указателем на буфер msg и размером msg_size, чтобы получить данные сообщения.
Далее функция преобразует массив символов msg в объект string, используя конструктор string(char*), который создает новую строку из последовательности символов, хранящихся в буфере msg.
В конце функция освобождает выделенную динамическую память с помощью оператора delete[].
Функция возвращает объект string, содержащий принятое сообщение.
*/
string RecvMsg() //Функция приема строковых сообщений
{
	int msg_size = 0;
	recv(Connection, (char*)&msg_size, sizeof(int), NULL);
	char* msg = new char[msg_size + 1];
	msg[msg_size] = '\0';
	recv(Connection, msg, msg_size, NULL);
	string str_msg = msg;
	delete[] msg;
	return str_msg;
}
//ОПИСАНИЕ ФУНКЦИИ void RecvFile()
/*
Функция RecvFile получает от пользователя название и расширение файла, который нужно получить с сервера. Затем функция отправляет серверу название и расширение файла с помощью функции SendMsg.
Сервер ищет файл с указанным именем и расширением. Если файл существует, то сервер отправляет клиенту сообщение "FileFound", иначе "NoFile".
Если сервер находит файл, то он отправляет клиенту размер файла и данные файла по кусочкам, размер каждого кусочка определяется сервером и отправляется клиенту перед каждым кусочком. 
Клиент получает каждый кусочек данных и записывает его в создаваемый файл. После получения всего файла, клиент закрывает файл и выводит сообщение об успешном приеме файла и его сохранении в указанной директории. 
Если файл не существует на сервере, то клиент получает сообщение об этом и выводит соответствующее сообщение на экран.
*/
void RecvFile()//Получение файла с сервера
{
	string Name, Extension, Path = "D:\\Recv\\";//Переменная для хранения названия файла
	cout << "Введите название получаемого файла (Пример: Test): ";
	cin >> Name;
	cout << "Введите расширение получаемого файла (Пример: txt): ";
	cin >> Extension;
	string FullPath = Path + Name + "." + Extension;
	SendMsg(Name);
	SendMsg(Extension);
	answer = RecvMsg();
	if (answer == "FileFound") {
		ofstream File;
		File.open(FullPath, ios::binary);//Создаем файл для записи
		int SizeBuff = 0, SizeFile = 0, choice = 0;//Переменная для хранения буфера
		recv(Connection, (char*)&SizeFile, sizeof(int), NULL);//Получение размера файла
		do {
			recv(Connection, (char*)&SizeBuff, sizeof(int), NULL);//Получение от сервера размера передаваемого буфера
			char* Buff = new char[SizeBuff + 1]; //Выделение динамической памяти под буфер
			Buff[SizeBuff] = '\0';
			recv(Connection, Buff, SizeBuff, NULL);//Получение данных с сервера и запись в буфер
			for (int i = 0; i < SizeBuff; i++) {
				File << Buff[i];//Запись в файл по-символьно
			}
			SizeFile = SizeFile - SizeBuff; //Учет оставшегося размера
		} while (SizeFile > 0);
		File.close();
		cout << "Файл " << Name << " успешно принят и сохранен в " << Path << endl;
	}
	else if (answer == "NoFile")
	{
		cout << Name << " не существует" << endl;
	}
}
//ОПИСАНИЕ int main(int argc, const char* argv[])
/*
Данный код является клиентским приложением для передачи файлов по протоколу TCP/IP на языке программирования C++. Программа работает с библиотекой Winsock и использует сокеты для подключения к серверу.
Сначала программа устанавливает соединение с сервером и проверяет его успешность. Затем она запрашивает логин и пароль для аутентификации, отправляет их на сервер, получает ответ и, если аутентификация прошла успешно, продолжает работу. Если же аутентификация не удалась, то программа завершает работу.
Если авторизация прошла успешно под учетной записью администратора, то программа запрашивает количество передаваемых файлов и отправляет это значение на сервер.
После этого программа запускает цикл, который позволяет пользователю получать файлы с сервера, отправлять файлы на сервер и завершать работу. При выборе получения файла пользователь вводит команду "Recv" и программа начинает получение файла с сервера. При выборе отправки файла пользователь указывает путь к файлу, который он хочет отправить на сервер. 
Если введенная команда не соответствует ни одному из доступных действий, программа выводит сообщение об ошибке и продолжает работу.
*/
int main(int argc, const char* argv[])
{
	setlocale(LC_ALL, "");
	cout << "CLIENT (Afonkin 20PT1)" << endl;
	WSAData wsaData;//Инициализация библиотеки Winsock
	WORD DDLVersions = MAKEWORD(2, 1);// Установка версии библиотеки
	WSAStartup(DDLVersions, &wsaData);// 1-ый параметр - версия; 2-ой параметр - ссылка на структуру
	WSAData;
	if (WSAStartup(DDLVersions, &wsaData) != 0) {// Проверка подключения библиотеки
		cout << "WSAStart error" << endl;
		return 0;
	}
	Connection = socket(AF_INET, SOCK_STREAM, 0);// Установка значений сокета
	if (Connection < 0) // Если значения сокета не установлены
	{
		cout << "Socket() error" << endl;
		return 0;
	}
	SOCKADDR_IN address;//Связывание сокета с локальным адресом
	int sizeOFaddress = sizeof(address);//Размер адреса
	address.sin_port = htons(PORT); // заполнение структуры sockaddr_in. Указание адреса и порта сервера
	address.sin_family = AF_INET;// Записываем идентификатор домена
	address.sin_addr.s_addr = 0;//не забываем о сетевом порядке, IP адрес хоста
	HOSTENT* hst;
	if (inet_addr(IP_ADDR) != INADDR_NONE)//преобразование IP адреа из символьного в сетевой формат
		address.sin_addr.s_addr = inet_addr(IP_ADDR);// Устанавливаем сетевой порядок, IP адрес хоста
	else
		if (hst = gethostbyname(IP_ADDR))// попытка получить IP адрес по доменному имени сервера
			((unsigned long*)&address.sin_addr)[0] = ((unsigned long**)hst->h_addr_list)[0][0];
		else
		{
			closesocket(Connection); //закрываем сокет
			WSACleanup();//Деиницилизация библиотеки Winsock
			cout << "Invalid address" << endl;
			return 0;
		}
	if (connect(Connection, (sockaddr*)&address, sizeof(address)))//адрес сервера получен–пытаемся установить соединение
	{
		closesocket(Connection);//закрываем сокет
		WSACleanup();//Деиницилизация библиотеки Winsock
		cout << "Connect error" << endl;
		return 0;
	}
	int nclients = 0;//Переменная для хранения количества подключенных клиентов
	recv(Connection, (char*)&nclients, sizeof(int), NULL);//Получение от сервера число подключенных клиентов
	if (nclients < 100) {//Если меньше одного, то
		string SendMess;
		string Check;
		string Check_log;
		string login;
		string password;
		cout << "Введите логин: ";
		cin >> login;//Ввод логина
		SendMsg(login);//Отправка логина на сервер
		cout << "Введите пароль: ";
		cin >> password;//Ввод пароля
		SendMsg(password);//Отправка пароля на сервер
		Check_log = RecvMsg();//Получение ответа от сервера
		if (Check_log == "Ok_login") { //Аутентификация, прихдит ответ от сервера
			cout << "Аутентификация прошла успешно" << endl;
		}
		else {
			cout << "Аутентификация не удалась" << endl;
			closesocket(Connection);//закрываем сокет
			WSACleanup();//Деиницилизация библиотеки Winsock
			return 0;
		}
		int NFiles;
		if (login == "admin" && password == "admin") {
			cout << "Введите число передаваемых файлов: ";
			cin >> NFiles;//Если авторизация произошла под админкой, то вводится число передаваемых файлов
			SendInt(NFiles);//Отправка числа передаваемых файлов на сервер
		}
		do {
			cout << "Введите Recv для получения файла с сервера (для выхода введите Exit): ";
			cin >> SendMess;
			int size = SendMess.size();
			send(Connection, (char*)&size, sizeof(int), NULL);
			send(Connection, SendMess.c_str(), size, NULL);
			Check = RecvMsg();
			if (Check == "Ok_Files") {
				if (SendMess == "Recv")
				{
					RecvFile();
				}
			}
			else {
				cout << "Ошибка: Превышено число получаемых файлов с сервера!" << endl;
			}
		} while (SendMess != "Exit");
		cout << "Выполнение отключения" << endl;
		closesocket(Connection);//закрываем сокет
		WSACleanup();//Деиницилизация библиотеки Winsock
	}
	else {
		cout << "Сервер переполнен" << endl;
		closesocket(Connection);//закрываем сокет
		WSACleanup();//Деиницилизация библиотеки Winsock
		return 0;
	}
	return 0;

}
